[{"title":"Java Concurrency Perspective Overview (一) </br> Java 并发透视之初窥探（一）","date":"2017-03-24T04:07:01.000Z","path":"posts/java/concurrency/java-concurrency-perspective-001-overview.html","text":"Java 并发透视之初窥探（一）概述Java是一种支持多线程编程的语言，意味着，我们可以使用Java开发多线程程序。一个多线程程序包含两个或多个可以同时运行的部件，每个部件可以同时处理不同的任务，特别是当计算机有多个CPU时，可以有效地利用可用资源。多任务是指多个进程共享共同的处理资源，如CPU。多线程将多任务的概念扩展到可以将单个应用程序中的特定操作细分为单个线程的应用程序。每个线程可以并行运行。OS不仅在不同的应用程序之间划分处理时间，而且在应用程序中的每个线程之间划分处理时间。多线程使您能够以同一程序同时进行多个活动的方式进行写入。 线程的生命周期线程生命周期经历了几个阶段：线程诞生，启动，运行，阻塞，死亡。下图简要显示了一个线程的完整生命周期。 +-------------+ start() \\=-------------=/ new Thread()--&gt;| New |------------&gt;\\ Runnable /&lt;---------+ +------+------+ \\-----+-----/ | | | | | |run() | v End of v | +------+------+ execution /------+-------\\ | End&lt;--\\ Dead /&lt;------------| Running | | -------+------- \\------+-------/ | Release Block ^ | | | |sleep(), wait() | | =-------------= | | +------| Blocked |&lt;-----+ | =------+------= | | | | | +-------------------------------+ Life cycle of a Thread ----------------------------- 以下是生命周期的各个阶段简述： 新的（New） - 新线程在新的状态下开始其生命周期。直到程序启动线程为止，它保持在这种状态。它也被称为新生线程。 可运行的（Runnable） - 新诞生的线程启动后，该线程可以运行。该状态的线程被认为正在执行其任务。但是，可能还未正式运行，可能在等待资源，如：CPU。 运行中的（Running） - 新诞生的线程启动后，如果，所有的准备条件已经满足，该线程会从准备运行状态进入运行状态，执行任务。 等待（Waiting） - 有时线程会转换到等待状态，而线程等待另一个线程执行任务。只有当另一个线程发信号通知等待线程才能继续执行时，线程才转回到可运行状态。 定时等待（Timed Waiting） - 可运行的线程可以在指定的时间间隔内进入定时等待状态。当该时间间隔到期或发生等待的事件时，此状态的线程将转换回可运行状态。 终止（Dead） - 可执行线程在完成任务或以其他方式终止时进入终止状态。 线程的优先级每一个线程都有一个优先级，可以帮助操作系统确定安排线程的顺序。 Java线程优先级在MIN_PRIORITY（常量为1）和MAX_PRIORITY（常量为10）之间的范围内。默认情况下，每个线程都被赋予优先级NORM_PRIORITY（常量为5）。 具有较高优先级的线程对于一个程序来说更重要，应该在低优先级线程之前分配处理器时间。然而，线程优先级不能保证线程执行的顺序，并且依赖于平台。 创建自己的第一个线程Java主要可以通过两种方式创建多线程的程序： 1.通过实现Runnable接口创建一个线程（推荐使用）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 实现Runnable接口的方式，创建线程 * * @author Asion * @since 2017/03/24 */class RunnableDemo implements Runnable &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; /** * 构造一个Runnable实例 * * @param name 线程名称 */ RunnableDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 普通start()方法 */ void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用线程类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestRunnable &#123; // 启动两个线程测试 public static void main(String args[]) &#123; RunnableDemo r1 = new RunnableDemo(\"Thread-1\"); r1.start(); RunnableDemo r2 = new RunnableDemo(\"Thread-2\"); r2.start(); &#125;&#125; 2.通过继承Thread类创建一个线程12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 继承Thread类，创建线程 * * @author Asion * @since 2017/03/24 */class ThreadDemo extends Thread &#123; // 持有Thread的一个引用 private Thread t; // 线程名称 private String threadName; ThreadDemo(String name) &#123; threadName = name; System.out.println(\"Creating \" + threadName); &#125; /** * 重写run()方法 * 从100倒数到1。 */ @Override public void run() &#123; System.out.println(\"Running \" + threadName); for (int i = 100; i &gt; 0; i--) &#123; System.out.println(\"Thread: \" + threadName + \", \" + i); &#125; System.out.println(\"Thread \" + threadName + \" exiting.\"); &#125; /** * 重写父类的start()方法 * 谨慎重写父类的start()方法 */ @Override public void start() &#123; System.out.println(\"Starting \" + threadName); if (t == null) &#123; t = new Thread(this, threadName); // 真正调用父类的start()方法，启动线程 t.start(); &#125; &#125;&#125;public class TestThread &#123; // 启动两个线程测试 public static void main(String args[]) &#123; ThreadDemo t1 = new ThreadDemo(\"Thread-1\"); t1.start(); ThreadDemo t2 = new ThreadDemo(\"Thread-2\"); t2.start(); &#125;&#125; 我们来简单分析一下多线程的程序 首先，我们的RunnableDemo实现的Runnable接口，那必须重写run()方法，run()就是线程running运行的方法，是线程体。 当new一个Thread实例，传入我们的RunnableDemo实例，这时线程生命周期处在新建（new）阶段； 然后，当调用Thread实例的start()方法时，说明线程已经准备就绪，转到了就绪（Runnable）状态； 如果此时，分配到了CPU，调用了run()方法开始执行，就转到运行（Running）状态； 当run()方法运行结束，线程就结束；或者run()方法中异常导致线程结束退出。 通过这一小节我们，我们了解java线程的创建和启动。下一节我们来看看java多线程的主要操作。","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://luxuexian99.github.io/categories/java/"},{"name":"concurrency","slug":"java/concurrency","permalink":"http://luxuexian99.github.io/categories/java/concurrency/"}],"tags":[{"name":"java","slug":"java","permalink":"http://luxuexian99.github.io/tags/java/"},{"name":"concurrency","slug":"concurrency","permalink":"http://luxuexian99.github.io/tags/concurrency/"}]},{"title":"JUnit Tutorial 系列教程(一) JUnit概述","date":"2017-03-24T02:07:23.000Z","path":"posts/testing/junit-totulrial-s1-001-index.html","text":"JUnit 系列教程(一) JUnit概述&emsp;&emsp;JUnit是Java编程语言的单元测试框架。JUnit在测试驱动开发中一直很重要，它起源于统称为xUnit的单元测试框架。 Overview&emsp;&emsp;软件测试是检查应用程序的功能确保其按照要求运行的过程。单元测试是在开发层面的；它是单个个体（类或方法）的测试。单元测试对于提高软件质量有着重要的帮助，在帮助软件公司向客户提供优质的产品方面发挥关键作用。单元测试可以通过两种方式进行： 手动测试：在没有任何工具支持的情况下手动执行测试用例称为手动测试。 自动测试：使用自动化工具进行工具支持和执行测试用例称为自动化测试。 两种方式对比： 手动测试 自动测试 耗时和乏味 - 由于测试用例是由人力资源执行的，所以非常慢而繁琐。 快速 - 自动化运行测试用例明显快于人力资源。 对人力资源的巨大投入 - 由于测试用例需要手动执行，所以在手动测试中需要更多的测试人员。 减少对人力资源的投入 - 使用自动化工具执行测试用例，因此在自动化测试中需要较少的测试人员。 不太可靠 - 手动测试不太可靠，因为它必须解决人为错误。 更可靠 - 自动化测试精确可靠。 不可编程 - 无需编写可编写复杂测试来获取隐藏信息的编程。 可编程 - 测试人员可以对复杂的测试进行编程，以提供隐藏的信息。 什么是JUnit？&emsp;&emsp;JUnit是Java编程语言的单元测试框架。它是测试驱动开发中的关键角色，并且是统称为xUnit的单元测试框架系列。&emsp;&emsp;JUnit提出了“首先测试然后编码”的想法，其强调为首先测试然后实现的一段代码设置测试数据。这种方法就像“测试一点，代码一点，测试一点，代码一点”。它提高了程序员的生产力和程序代码的稳定性，从而降低了程序员的压力和调试时间。 JUnit的特性 JUnit是一个开源框架，开源社区活跃。 提供注解的方式来识别测试方法。 提供用于测试预期结果的断言。 提供运行测试的测试Runner。 JUnit测试允许您更快地编写代码，从而提高质量。 JUnit优雅简单。它不那么复杂，花费更少的时间。 JUnit测试可以自动运行，并检查自己的结果并提供即时反馈。没有必要手动梳理测试结果的报告。 JUnit测试可以组织成包含测试用例的测试套件，甚至其他测试套件。 如果测试运行平稳，JUnit会显示一个绿色的测试进度，当测试失败时，它会变为红色。 什么是单元测试用例？&emsp;&emsp;单元测试用例是代码的一部分，可以确保代码（方法）的另一部分按预期工作。为了快速实现所需的结果，需要一个测试框架。JUnit是Java编程语言的完美单元测试框架。&emsp;&emsp;正式的书面单元测试用例的特征在于已知的输入和预期的输出，在测试执行之前计算出来。已知输入应测试前提条件，预期输出应测试后期条件。&emsp;&emsp;每个要求必须至少有两个单元测试用例 - 一个正测试和一个负测试。如果要求有次级要求，则每个子要求必须至少有两个测试用例为正值和负数。 第一个测试用例12345678public class FirstJUnitTestCase &#123; @Test public void testString() &#123; String str = \"JUnut 已经成功运行！\"; // 断言String是否相等 assertEquals(\"JUnut 已经成功运行！\", str); &#125;&#125;","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://luxuexian99.github.io/categories/java/"},{"name":"testing","slug":"java/testing","permalink":"http://luxuexian99.github.io/categories/java/testing/"}],"tags":[{"name":"java","slug":"java","permalink":"http://luxuexian99.github.io/tags/java/"},{"name":"testing","slug":"testing","permalink":"http://luxuexian99.github.io/tags/testing/"},{"name":"junit","slug":"junit","permalink":"http://luxuexian99.github.io/tags/junit/"}]},{"title":"Java leaning road 从菜佳娃到佳娃假购师","date":"2017-03-21T13:48:57.000Z","path":"posts/java/java-leaning-road.html","text":"Java学习之路 从菜佳娃–&gt;佳娃假购师","excerpt":"","categories":[{"name":"java","slug":"java","permalink":"http://luxuexian99.github.io/categories/java/"}],"tags":[{"name":"java","slug":"java","permalink":"http://luxuexian99.github.io/tags/java/"}]},{"title":"道德经","date":"2017-01-17T07:31:36.000Z","path":"posts/life/my-life-way.html","text":"道德经我们是谁 第一章 道, 可道非常道; 名, 可名非常名 无, 名天地之始; 有, 名万物之母 故常无欲以观其妙。常有欲以观其徼。此两者同出而异名，同谓之玄。玄之又玄，众妙之门。 天下皆知美之为美，斯恶矣；皆知善之为善，斯不善已。故有无相生，难易相成，长短相形，高下相 倾，音声相和，前後相随。是以圣人处无为之事，行不言之教。万物作焉而不辞。生而不有，为而不恃， 功成而弗居。夫唯弗居，是以不去。 不尚贤， 使民不争。不贵难得之货，使民不为盗。不见可欲，使民心不乱。是以圣人之治，虚其心， 实其腹，弱其志，强其骨；常使民无知、无欲，使夫智者不敢为也。为无为，则无不治。 道冲而用之，或不盈。渊兮似万物之宗。解其纷，和其光，同其尘，湛兮似或存。吾不知谁之子，象 帝之先。 05.天地不仁，以万物为刍狗。圣人不仁，以百姓为刍狗。天地之间，其犹橐迭乎？虚而不屈，动而愈出 。多言数穷，不如守中。 06.谷神不死是谓玄牝。玄牝之门是谓天地根。绵绵若存，用之不勤。 07.天长地久。天地所以能长且久者，以其不自生，故能长生。是以圣人後其身而身先，外其身而身存。 非以其无私邪！故能成其私。 08.上善若水。水善利万物而不争，处众人之所恶，故几於道。居善地，心善渊，与善仁，言善信，正善 治，事善能，动善时。夫唯不争，故无尤。 09.持而盈之不如其己；揣而锐之不可长保；金玉满堂莫之能守；富贵而骄，自遗其咎。功遂身退，天之 道。 10.载营魄抱一，能无离乎？专气致柔，能如婴儿乎？涤除玄览，能无疵乎？爱国治民，能无为乎？天门 开阖，能为雌乎？明白四达，能无知乎。 我们从哪里来11.三十幅共一毂，当其无，有车之用。埏埴以为器，当其无，有器之用。凿户牖以为室，当其无，有室 之用。故有之以为利，无之以为用。 12.五色令人目盲，五音令人耳聋，五味令人口爽，驰骋畋猎令人心发狂，难得之货令人行妨。是以圣人 ，为腹不为目，故去彼取此。 13.宠辱若惊，贵大患若身。何谓宠辱若惊？宠为下。得之若惊失之若惊是谓宠辱若惊。何谓贵大患若身 ？吾所以有大患者，为吾有身，及吾无身，吾有何患。故贵以身为天下，若可寄天下。爱以身为天下，若 可托天下。 14.视之不见名曰夷。听之不闻名曰希。抟之不得名曰微。此三者不可致诘，故混而为一。其上不皦 (jiǎo)，其下不昧，绳绳不可名，复归於无物。是谓无状之状，无物之象，是谓惚恍。迎之不见其首，随 之不见其後。执古之道以御今之有。能知古始，是谓道纪。 15.古之善为士者，微妙玄通，深不可识。夫唯不可识，故强为之容。豫兮若冬涉川；犹兮若畏四邻；俨 兮其若容；涣兮若冰之将释；敦兮其若朴；旷兮其若谷；混兮其若浊；澹兮其若海；飉(liáo,风的声音)兮 若无止。孰能浊以静之徐清。孰能安以动之徐生。保此道者不欲盈。夫唯不盈故能蔽而新成。 16.致虚极守静笃。万物并作，吾以观复。夫物芸芸各复归其根。归根曰静，是谓复命；复命曰常，知常 曰明。不知常，妄作凶。知常容，容乃公，公乃全，全乃天，天乃道，道乃久，没身不殆。 17.太上，下知有之。其次，亲而誉之。其次，畏之。其次，侮之。信不足焉，有不信焉。悠兮其贵言， 功成事遂，百姓皆谓∶我自然。 18.大道废有仁义；慧智出有大伪；六亲不和有孝慈；国家昏乱有忠臣。 19.绝圣弃智，民利百倍；绝仁弃义，民复孝慈；绝巧弃利，盗贼无有；此三者，以为文不足。故令有所 属，见素抱朴少私寡欲。 20.绝学无忧，唯之与阿，相去几何？善之与恶，相去若何？人之所畏，不可不畏。荒兮其未央哉！众人 熙熙如享太牢、如春登台。我独泊兮其未兆，如婴儿之未孩；儡儡(lěi,羸弱)兮若无所归。众人皆有馀，而 我独若遗。我愚人之心也哉！沌沌兮。俗人昭昭，我独昏昏；俗人察察，我独闷闷。众人皆有以，而我独 顽且鄙。我独异於人，而贵食母。 我们要到哪里去","excerpt":"","categories":[{"name":"life","slug":"life","permalink":"http://luxuexian99.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"http://luxuexian99.github.io/tags/life/"},{"name":"国学","slug":"国学","permalink":"http://luxuexian99.github.io/tags/国学/"}]},{"title":"Hexo Quick Start","date":"2016-10-26T20:56:25.000Z","path":"posts/hexo-quick-start.html","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","excerpt":"","categories":[{"name":"hexo","slug":"hexo","permalink":"http://luxuexian99.github.io/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://luxuexian99.github.io/tags/hexo/"}]},{"title":"Git版本控制与Git Flow工作流程","date":"2016-08-26T12:33:25.000Z","path":"posts/git-flow.html","text":"GIT版本控制与工作流程修订历史记录 日期：2016-08-26版本：0.1修订人：Asion Lu备注：修订版 引言编写的目的 通过规范化的流程，使得产品、开发与测试等各个部门更高效的协同工作。 通过规范化的流程使得产品高效稳定运行。 背景在多组员，多项目等环境进行协同工作时，如果没有统一规范、统一流程，则会导致额外的工作量，甚至会做无用功。所以要减少版本冲突，减轻不必要的工作，就需要规范化的工作流程。 总则 统一使用Git作为版本控制的主要工具。 统一使用GitFlow流程管理控制版本。 提交的准则 除了源码相关的东西之外，其他build产生的东西（如：maven的target文件夹，.idea文件夹等），均不能提交进入源码仓库，添加到.gitignore文件中忽略掉。 撰写规范的提交说明。一份好的提交说明可以帮助协作者更轻松更有效地配合工作。 要严格按照我们指定的流程切换到指定分支，开发相应的功能。 分支简述我们使用的分支流程： 天蓝色圆点所在的线为我们源码的主线（master）。 天蓝色方形指向的节点就是每一个发布版本的标签（tag）。 紫色圆点所在的线为主要分支线（develop）。 橙色圆点所在的线为新功能开发分支线（feature）。 绿色圆点所在的线为新版本发布线（release）。 红色圆点所在的线为发布版本bug修复线（hotfix）。 主分支说明代替原来的单个主线（master），我们使用两个分支来记录源码轨迹： 原来的master分支用来记录官方发布轨迹； 新的develop分支是一个集成分支，用来记录开发新功能的轨迹。除了master主线和develop主分支线，其他的分支都是临时的分支，有一定的生命周期的，其余的工作流程分支都是围绕这两个分支之间的区别进行的。 其他分支说明 新功能分支（Feature Branches） 每一个新的功能都应该创建一个独立的分支，从develop分支中派生出来。当功能完成后，要合并（merged）回develop分支，合并后它的生命周期就结束。新功能分支不会与master分支有直接的交汇。如图： 注意：对于所有意图和目的，新功能分支会合并到develop分支。但是，这个Gitflow工作流不会在此结束。 发布分支（Release Branches） 一旦开发的功能已经满足发布条件（或预定发布日期接近），应该合并所有满足发布条件的新功能分支到develop分支中，然后，开出一个发布分支（Release），开始准备一个发布版本。在这个分支上，不能再添加新的功能，只有bug修复和该版本为导向的任务。一旦到了发布日期，Release就要合并回master发布，并且，打出版本标签。另外，还需要合并回develop分支。 使用一个专门的分支来准备发布版本，使得一个团队能对当前版本进行抛光，而另一个团队继续为下一个版本的功能做准备。它还创造了良好定义的发展阶段（例如，很容易说，“本周我们正在准备4.0版”，而且真实地看到它在库中的结构）。 维护分支（Maintenance Branches） 维护分支也就是线上bug修复分支，使用来快速修复生产环境的紧急问题。 这个分支是唯一一个开放过程中直接从master分支派生来的分支。快速的修复问题后，它应该被合并回master和develop（或者当前发布分支），然后，master分支需要打一个版本标签。 一个专门的错误修复开发线，可以让团队在不等待下一个发布周期，导致中断工作流程情况下解决问题。可以将维护分支当做主要的问题修复分支，与master并行。 命名约定 主分支名称：master 主开发分支名称：develop 标签（tag）名称：v*.RELEASE，其中”*“ 为版本号，“RELEASE”大写，如：v1.0.0.RELEASE 新功能开发分支名称：feature-* or feature/*，其中“*” 为新功能简述，如：feature-item-activity-list 发布分支名称：release-* or release/*，其中* 为版本号，“release”小写，如：release-1.0.0 master的bug修复分支名称：hotfix-* or hotfix/* ，其中* 为bug简述，如：hotfix/item-update-bug工作流程下面具体演示如何使用工作流来管理版本发布周期。假设我们已经存在或创建了一个源码中央存储仓库。 工作流的基础创建develop分支 项目负责人在本地master基础上创建一个develop分支，然后，推送到服务器； 12git branch developgit push -u origin develop 其他开发人员，需要克隆develop中央仓库的源码，创建一个develop的轨迹版本；如果，已经克隆过该项目，则，不需要执行以下第一条命令。 12git clone git@bitbucket.org:ytx-dev/ytx-demo.gitgit checkout -b develop origin/develop develop这个分支将包含项目的完整历史记录，而master将包含缩略版本。 假设开始以下所有的流程之前，都已经创建好develop分支。 新功能开发流程 新建feature分支 基于develop分支创建新功能分支： 1git checkout -b feature/demo develop 推送到远程仓库，共享： 1git push 所有开发此新功能的人员，都在此分支上开发提交代码。 123git statusgit add &lt;some-file&gt;git commit -m \"Add some-file.\" 完成新功能开发（合并feature分支到develop） 当确定新功能开发完成，且联调测试通过，并且新功能负责人已经得到合并feature分支到develop分支的允许；这样才能合并feature分支到develop。 12345git pull origin develop git checkout developgit merge feature/demogit pushgit branch -d feature/demo 第一条命令是确保在合并新功能之前，develop分支是最新的。 注意： 新功能分支，永远不要直接合并到master分支。 合并可能会有冲突，应该谨慎处理冲突。 在测试环境发布develop分支代码（提交测试） 线上版本发布流程 从develop中创建准备发布的release分支 当主测试流程完成，源码已经趋近于稳定状态，应该准备一个发布版本，确立版本号： 1git checkout -b release-0.1.0 develop 推送到远程仓库共享： 1git push 这个分支是清理准备发布、 整体回归测试、 更新文档，和做其他任何系统即将发布的事情。 继续抛光改bug release分支合并到master发布 一旦已经满足发布条件（或已经到了预定发布日期），应该把release分支合并到master分支和develop分支中，然后，使用master发布新版本。合并release分支到develop分支是很重要的，要让release上修改的东西能在后续的开发分支中生效。 123git checkout mastergit merge release-0.1.0git push release分支合并到develop 1234 git checkout developgit merge release-0.1.0git pushgit branch -d release-0.1.0 打标签 Release分支在功能开发分支（develop）和公共发布版（master）中，充当一个缓冲的作用。每当有源码合并到master中的时候，应该在master上打一个标签，以便后续跟踪查阅。 12git tag -a 0.1.0.RELEASE -m \"Initial public release\" mastergit push --tags 线上Bug修复流程当终端用户，反馈系统有bug时，为了处理bug，需要从master中创建出保养分支；等到bug修复完成，需要合并回master： 创建hotfix分支 1git checkout -b issue-#001 master 修改bug Fix the bug 完成修复，合并到master发布 123git checkout mastergit merge issue-#001git push 打标签 12git tag -a 0.1.1.RELEASE -m \"Initial public release\" mastergit push --tags 合并到develop 123git checkout developgit merge issue-#001git push 其他附录参考资料 git-book what-is-version-control gitflow-workflow","excerpt":"","categories":[{"name":"VCS","slug":"VCS","permalink":"http://luxuexian99.github.io/categories/VCS/"},{"name":"git","slug":"VCS/git","permalink":"http://luxuexian99.github.io/categories/VCS/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://luxuexian99.github.io/tags/git/"},{"name":"git-flow","slug":"git-flow","permalink":"http://luxuexian99.github.io/tags/git-flow/"},{"name":"VCS","slug":"VCS","permalink":"http://luxuexian99.github.io/tags/VCS/"}]}]